% ────────────────────────────────────────────────────────────────────────────
\chapter{Pipeline dei Workflow n8n}
% ────────────────────────────────────────────────────────────────────────────

Il cuore logico del DIM è costituito da cinque workflow n8n interconnessi che implementano l'intera pipeline di discovery, analisi e raffinamento. Ogni workflow è un componente autonomo con interfacce well-defined, esportabile come file JSON e versionabile in Git.

\section{Mappa dei Workflow}

\begin{table}[H]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{L{3cm} L{3cm} L{7.5cm}}
\toprule
\textbf{Workflow} & \textbf{Trigger} & \textbf{Responsabilità} \\
\midrule
Routing & Webhook POST \texttt{/chat-locale} & Punto di ingresso unico; smista verso Discovery o Refinement \\
Discovery & Sub-workflow call & Pipeline di intervista a 5 fasi + generazione modello \\
Refinement & Sub-workflow call & Explain o Modify del modello architetturale \\
Polling & Webhook GET \texttt{/check-status-locale} & Verifica disponibilità del JSON architetturale \\
Draft Decision & Webhook POST \texttt{/draft-decision-locale} & Conferma o rifiuto delle bozze di modifica \\
\bottomrule
\end{tabularx}
\caption{Mappa completa dei workflow n8n}
\end{table}

\section{Routing Workflow}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/routing_workflow.png}
    \caption{Struttura del Routing Workflow nell'interfaccia n8n: gestione degli accessi e branching.}
    \label{fig:routing_workflow}
\end{figure}


Il Routing Workflow è il punto di ingresso dell'intera pipeline. Riceve i messaggi dallo stakeholder tramite webhook HTTP e decide dove instradarli.

\subsection{Logica di Routing Dettagliata}

\begin{enumerate}
  \item \textbf{Ricezione:} Il webhook POST \texttt{/chat-locale} riceve il payload \texttt{\{message, sessionId, action\}} dal frontend.
  \item \textbf{Verifica Stato:} Un nodo Redis GET controlla la chiave \texttt{discovery\_json:\{sessionId\}}:
  \begin{itemize}
    \item \textbf{Se NON esiste} (la discovery non è completata):
    \begin{itemize}
      \item Un secondo nodo Redis GET verifica \texttt{discovery\_phase:\{sessionId\}}.
      \item Se la fase non è inizializzata, un nodo Redis SET la imposta a \texttt{1}.
      \item Il messaggio viene inoltrato al Discovery Workflow tramite HTTP Request interna a \texttt{/webhook/discovery-internal} con timeout di 30 minuti (1.800.000 ms).
    \end{itemize}
    \item \textbf{Se esiste} (il modello è già disponibile): il messaggio viene inoltrato al Refinement Workflow tramite \texttt{/webhook/refinement-internal} con il campo \texttt{action} (explain/modify).
  \end{itemize}
  \item \textbf{Risposta:} La modalità \texttt{responseMode: lastNode} del webhook fa sì che la risposta HTTP venga restituita automaticamente dall'ultimo nodo della catena.
\end{enumerate}

\begin{technicalbox}{Dettaglio Tecnico: Timeout di 30 Minuti}
Il timeout dell'HTTP Request verso il Discovery Workflow è impostato a 1.800.000 ms (30 minuti). Questo valore tiene conto del caso peggiore: quando l'Orchestrator autorizza il completamento della Fase~5 e la catena DDD Analyst $\to$ JSON Coder deve processare l'intero storico conversazionale con un modello da 14B parametri in inferenza locale. Questa operazione può richiedere fino a 20 minuti.
\end{technicalbox}

\section{Discovery Workflow}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/discovery_workflow.png}
    \caption{Struttura del Discovery Workflow nell'interfaccia n8n}
    \label{fig:discovery_workflow}
\end{figure}

Il Discovery Workflow è il componente più complesso dell'intero sistema. Implementa la pipeline di intervista a cinque fasi con agenti specializzati e la catena di generazione del modello architetturale.

\subsection{Flusso di Esecuzione}

\begin{enumerate}
  \item \textbf{Ricezione:} Il webhook interno \texttt{/discovery-internal} riceve \texttt{message} e \texttt{sessionId} dal Routing Workflow.
  \item \textbf{Lettura Stato:} Due nodi Redis GET leggono in parallelo la fase corrente (\texttt{discovery\_phase:\{sessionId\}}) e lo storico della conversazione.
  \item \textbf{Valutazione Orchestrator:} Il messaggio e lo storico vengono sottoposti all'Orchestrator (Project Controller), un agente LLM dedicato che emette un verdetto:
  \begin{itemize}
    \item \textbf{WAIT} --- le informazioni raccolte non sono ancora sufficienti per la fase corrente.
    \item \textbf{PASS} --- la fase corrente è completata con dettaglio adeguato.
  \end{itemize}
  \item \textbf{Branching (nodo Switch):} Il verdetto determina il percorso:
  \begin{itemize}
    \item \textbf{Se WAIT:} Il messaggio viene instradato (tramite un secondo Switch) all'agente intervistatore della fase corrente, che prosegue l'intervista e restituisce la risposta all'utente.
    \item \textbf{Se PASS e la fase corrente $<$ 5:} La fase in Redis viene incrementata, e il messaggio viene instradato all'agente della \textbf{nuova} fase, che si presenta e pone la prima domanda del suo pillar.
    \item \textbf{Se PASS e la fase corrente = 5:} Il workflow restituisce immediatamente una risposta con \texttt{status: generating} e avvia la catena di generazione.
  \end{itemize}
  \item \textbf{Generazione (solo post-Fase~5):} La catena DDD Analyst $\to$ JSON Coder processa l'intero storico conversazionale, produce il documento Markdown e lo traduce in JSON strutturato, salvandolo in Redis come \texttt{discovery\_json:\{sessionId\}}.
\end{enumerate}

\subsection{Configurazione degli Agenti}

\begin{table}[H]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{L{3.2cm} C{1cm} C{1.5cm} C{1cm} C{1.8cm} L{4cm}}
\toprule
\textbf{Agente} & \textbf{Fase} & \textbf{Modello} & \textbf{Temp.} & \textbf{Memory Win.} & \textbf{Ruolo} \\
\midrule
Orchestrator & 1--5 & qwen2.5:14b & 0.0 & --- & Valutazione PASS/WAIT \\
Domain Interv. & 1 & llama3 & 0.4 & 10 msg & Intervista strategica \\
Context Interv. & 2 & llama3 & 0.4 & 20 msg & Intervista bounded context \\
Event Interv. & 3 & llama3 & 0.4 & 30 msg & Intervista eventi e comandi \\
Pattern Interv. & 4 & llama3 & 0.4 & 40 msg & Intervista pattern tattici \\
Resilience Interv. & 5 & llama3 & 0.4 & 50 msg & Intervista resilienza \\
DDD Analyst & Post & qwen2.5:14b & 0.3 & 200 msg & Generazione documento MD \\
JSON Coder & Post & qwen2.5:14b & 0.0 & --- & Traduzione MD $\to$ JSON \\
\bottomrule
\end{tabularx}
\caption{Configurazione completa degli agenti nel Discovery Workflow}
\end{table}

\newpage

\begin{technicalbox}{Dettaglio Tecnico: Memory Window Crescente}
La scelta di una memory window crescente (10 $\to$ 50 messaggi) è una decisione di prompt engineering motivata dall'accumulazione progressiva di informazioni. L'agente di Fase~1 necessita solo del contesto immediato per identificare i subdomini, mentre l'agente di Fase~5 deve avere visibilità sull'intera conversazione per garantire coerenza architetturale nelle domande su scalabilità e resilienza. Il DDD Analyst utilizza una finestra di 200 messaggi per avere accesso all'intero storico.
\end{technicalbox}

\section{Refinement Workflow}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/refinement_workflow.png}
    \caption{Struttura del Refinement Workflow nell'interfaccia n8n}
    \label{fig:refinement_workflow}
\end{figure}

Una volta generato il modello architetturale, lo stakeholder può interagire con esso attraverso due modalità.

\subsection{Modalità Explain (Spiegazione)}

L'agente Explainer riceve la domanda dell'utente e il JSON architetturale corrente (caricato da Redis). Risponde in italiano con spiegazioni tecniche basate esclusivamente sui dati del JSON, senza mai suggerire modifiche. Se l'utente chiede una modifica, lo reindirizza cortesemente verso la modalità Modify.

\subsection{Modalità Modify (Modifica)}

Il flusso di modifica segue un protocollo strutturato:
\begin{enumerate}
  \item L'agente Modifier riceve la richiesta e il JSON corrente.
  \item \textbf{Se la richiesta è vaga o troppo ampia:} risponde con un messaggio conversazionale chiedendo chiarimenti (non genera alcuna proposta).
  \item \textbf{Se la richiesta è chiara e azionabile:} produce un ``receipt'' Markdown strutturato con:
  \begin{itemize}
    \item \textbf{Azione:} ADD, MODIFY o DELETE.
    \item \textbf{Sezione Target:} Chiave JSON root (es. \texttt{boundaries\_and\_language}).
    \item \textbf{Path Interno:} Percorso esatto nell'albero JSON.
    \item \textbf{Elemento:} Nome dell'entità/evento/componente.
    \item \textbf{Dettagli/Payload:} Dati da iniettare.
  \end{itemize}
  \item La bozza viene salvata in Redis come \texttt{draft\_json:\{sessionId\}} con stato \texttt{pending}.
  \item L'utente visualizza la bozza di modifica e può confermare o rifiutare.
\end{enumerate}

\section{Polling Workflow}

Il Polling Workflow è un endpoint GET leggero che il frontend interroga periodicamente (ogni 3 secondi) per verificare se il JSON architetturale è diventato disponibile in Redis dopo la generazione post-Fase~5. Restituisce il contenuto di \texttt{discovery\_json:\{sessionId\}} se presente.

\section{Draft Decision Workflow}

Gestisce le azioni di conferma/rifiuto sulle bozze di modifica:
\begin{itemize}
  \item \textbf{Azione ``conferma'':} Il workflow recupera la bozza (\texttt{draft\_json}) e il JSON architetturale corrente (\texttt{discovery\_json}), poi un nodo JavaScript applica chirurgicamente la modifica (ADD, MODIFY o DELETE) alla struttura JSON. Se l'operazione ha successo, il JSON aggiornato viene salvato in \texttt{discovery\_json}; in caso di errore (elemento non trovato, dati corrotti), lo stato viene impostato a \texttt{failed}.
  \item \textbf{Azione ``rifiuta'':} Elimina la bozza (\texttt{draft\_json}), mantenendo \texttt{discovery\_json} invariato.
\end{itemize}

In entrambi i casi, la \textbf{chat memory del refinement} (\texttt{chat\_history\_refinement:\{sessionId\}}) viene cancellata al termine dell'operazione, resettando il contesto conversazionale per le interazioni successive.

\section{Comunicazione tra Workflow}

I workflow comunicano tra loro attraverso due meccanismi:

\begin{enumerate}
  \item \textbf{HTTP Request Interne:} Il Routing Workflow invoca Discovery e Refinement tramite webhook interni (\texttt{http://localhost:5678/webhook/discovery-internal} e \texttt{/refinement-internal}). Questa scelta consente di mantenere ogni workflow come unità autonoma testabile indipendentemente.
  \item \textbf{Redis come Bus di Stato:} Lo stato condiviso transita esclusivamente attraverso Redis. Nessun workflow mantiene stato in memoria tra invocazioni diverse.
\end{enumerate}
